# Homework № 2

# Algo

## [Interleaving-string](https://leetcode.com/problems/interleaving-string/description/)

Сначала проверяем равенство длин s3 и s1 + s2, чтобы сразу отсечь невозможные варианты.
Затем применяем динамику - строим логический двумерный массив isParse

Хотим вернуть true когда все строки пустые, поэтому isParse(0, 0) == true.
В остальных случаях isParse(i, j) == true если s3(0, i+j-1) это чередование s1(0, i-1) и s2(0, j-1)

Будем обновлять isParse(i, j) следующим образом: если s1(i-1) == s3(i+j-1), то обновляем значение таблицы в соответствии с isParse(i-1, j).
Аналогично обновляем таблицу с помощью s2

В конце возвращаем isParse(len(s1), len(s2))

Однако можно лучше: заметим, что мы двигаемся по isParse снизу вверх слева направо.
Таким образом, можно уменьшить занимаемую память с O(|s1|*|s2|) до O(|s2|), если хранить в памяти текущую строку матрицы isParse.
Левое значение уже будет вычислено, а верхнее еще не будет перезаписано в текущей ячейке

## [Trapping-rain-water](https://leetcode.com/problems/trapping-rain-water/description/)

Идея - для каждого элемента массива найдем высоту самого высокого столба слева и справа от него.
Разница между высотой текущего столба и минимумом из двух найденных - это кол-во воды, которое хранится над текущим столбом

~~Чтобы каждый раз заново не искать максимум в подмассиве, можно заранее подсчитать массивы left, right значений самых высоких столбов слева и справа от текущего~~

~~Тогда останется просто пройтись по массиву столбов и "за линию" посчитать ответ~~

Можно не подсчитывать заранее массивы, а использовать два указателя, на каждом шаге обновляя значения максимумов