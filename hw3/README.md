# Homework № 3

# [Best-time-to-buy-and-sell-stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/)

Отслеживаем минимальную цену в уже прочитанном массиве и потенциальную прибыль, если мы продадим акцию по текущей цене

Выбираем максимальную потенциальную прибыль

# [Single-number-iii](https://leetcode.com/problems/single-number-iii/description/)

Сначала сортируем числа

Затем идем по отсортированному массиву, пропуская повторяющие числа. То что остается добавляем в ответ.
Также в конце проверяем, если два числа еще не найдены, то это значит, что второе число стоит на последнем месте в отсортированном массиве

Решение работает за O(1) по памяти и за O(n * log n) по времени из-за сортировки. Наверное можно улучшить время до O(n), но я не придумал как

# [Unique-binary-search-trees-ii](https://leetcode.com/problems/unique-binary-search-trees-ii/description/)

Реализуем рекурсивный подход

Используем функцию, которая генерирует все структурно-уникальные BST, содержащие узлы от min до max включительно.
Внутри этой функции проходим по всем числам от min до max и рекурсивно вызываем функцию для левого и правого узлов

Результат работы функции от 1 до n - ответ

# [Number-of-islands](https://leetcode.com/problems/number-of-islands/description/)

Применяем алгоритм поиска компонент связности с помощью dfs

Если текущее не посещенное поле это "земля", то запускаем с него обход и отмечаем всю достижимую землю как visited - это первая компонента связности.
Повторяем, пока не останется не посещенной земли, попутно подсчитывая кол-во запусков

# [Redundant-connection-ii](https://leetcode.com/problems/redundant-connection-ii/description)

Для начала переберем ребра графа, отслеживая их начала. Если мы нашли вершину, в которую ведут два ребра, то какое-то из них является ответом.
Если такой вершины нет, то нам нужно будет найти ребро, которое образует цикл

Далее снова идем по всем ребрам, объединяя множества вершин. Если какие-то вершины уже объединены, то значит мы нашли цикл и можно возвращать ответ  

Объединять множества вершин будем с помощью DSU - это структура данных, которая позволяет быстро объединить два каких-либо множества, а также узнать, в каком множестве сейчас находится указанный элемент.
Реализацию DSU возьмем с курса алгоритмов - используем эвристику сжатия путей (можно было использовать и эвристику объединения по рангу, но тогда по памяти будет так себе) 
